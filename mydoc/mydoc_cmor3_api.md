---
title: CMOR Application program interface (API)
keywords: documentation 
last_updated: June 12, 2016
tags: [getting_started]
sidebar: mydoc_sidebar
permalink: /mydoc_cmor3_api/
---

### cmor_setup

<span style="color:green">
Fortran: error_flag = cmor_setup(inpath='./', netcdf_file_action=CMOR_PRESERVE, set_verbosity=CMOR_NORMAL, exit_control=CMOR_NORMAL, logfile, create_subdirectories)</span>

<span style="color:blue">C: error_flag = cmor_setup(char *inpath, int *netcdf_file_action, int *set_verbosity, int *exit_control, char*logfile, int *create_subdirectories) </span>

<span style="color:coral">Python: setup(inpath='.', netcdf_file_action=CMOR_PRESERVE, set_verbosity=CMOR_NORMAL, exit_control=CMOR_NORMAL, logfile=None, create_subdirectories=1)</span>
 
*Description:* Initialize CMOR, specify path to MIP table(s) that will be read by CMOR, specify whether existing output files will be overwritten, and specify how error messages will be handled
 
*Arguments:*

* **[inpath]** = a character string specifying the path to the directory where the needed MIP-specific tables reside.

* **[netcdf_file_action]** = controls handling of existing netCDF files.  If the value passed is CMOR_REPLACE, a new file will be created; any existing file with the same name as the one CMOR is trying to create will be overwritten.  If the value is CMOR_APPEND, an existing file will be appended; if the file does not exist, it will be created.  If the value is CMOR_PRESERVE, a new file will be created unless a file by the same name already exists, in which case the program will error exit.[8] To generate a NetCDF file in the "CLASSIC" NetCDF3 format, a "_3" should be appended to the above parameters (e.g., CMOR_APPEND would become CMOR_APPEND_3). To generate a NetCDF file in the "CLASSIC" NetCDF4 format, a "_4" should be appended to the above parameters (e.g., CMOR_APPEND would become CMOR_APPEND_4), this allows the user to take advantage of NetCDF4 compression and chunking capabilities. The default values (no underscore) are aliased to the _3 values (satisfying the requirements of CMIP6).

* **[set_verbosity]** controls how informational messages and error messages generated by CMOR are handled.  If set_verbosity=CMOR_NORMAL, errors and warnings will be sent to the standard error device (typically the user's screen). If verbosity=CMOR_QUIET, then only error messages will be sent (and warnings will be suppressed). 

* **[exit_control]** determines if errors will trigger program to exit: 
  * CMOR_EXIT_ON_MAJOR = stop only on critical error; 
  * CMOR_NORMAL = stop only if severe errors; 
  * CMOR_EXIT_ON_WARNING = stop even after minor errors detected.

* **[logfile]** where CMOR will write its messages -- default is "standard error" (stderr). 

* **[create_subdirectories]** do we want to create the correct path subdirectory structure or simply dump the files wherever cmor_dataset will point to. 
 
\Returns upon success:

* <span style="color:green">Fortran: 0 </span>
* <span style="color:blue"> C: 0 </span>
* <span style="color:coral">Python: None </span>


---

### cmor_get_cur_dataset_attribute

<span style="color:green"> Fortran: error_flag = cmor_get_cur_dataset_attribute(name,result) </span>

<span style="color:blue"> C: error_flag = cmor_get_cur_dataset_attribute(char *name, char *result) </span>

<span style="color:coral"> Python: result = get_cur_dataset_attribute(name) </span>

*Description*: Retrieves a global attribute associated with the current dataset.

*Arguments*:

* *name*  = name of the global attribute to retrieve.

* *result*  = string  (or pointer to a string), which is returned by the function and contains the retrieved global attribute (not for Python).

Returns upon success:

 * <span style="color:green"> Fortran: 0 </span>
 * <span style="color:blue"> C: 0 </span>
 * <span style="color:coral"> Python: None </span>

---

### cmor_has_cur_dataset_attribute

<span style="color:green"> Fortran: error_flag = cmor_has_cur_dataset_attribute(name)</span>

<span style="color:blue"> C: error_flag = cmor_has_cur_dataset_attribute(char *name)</span>

<span style="color:coral"> Python: error_flag = has_cur_dataset_attribute(name) </span>

*Description:* Determines whether a global attribute is associated with the current dataset.

*Arguments:*

* *name* = name of the global attribute of interest.

Returns:

* <span style="color:green"> a negative integer if an error is encountered; otherwise returns 0.</span>
* <span style="color:blue"> 0 upon success</span>
* <span style="color:coral"> True if the attribute exists, False otherwise.</span>

---

### cmor_load_table

<span style="color:green"> Fortran: table_id = cmor_load_table(table) </span>

<span style="color:blue"> C: error_flag = cmor_load_table(char *table, int *table_id)</span>

<span style="color:coral"> Python: table_id = load_table(table) </span>

**Description:**
Loads a table and returns a “handle” (table_id) to use later when defining CMOR components. CMOR will look for the table first followig the path as specified by the “table” argument passed to this function.  If it doesn’t find a file there it will prepend the outpath defined in calling cmor_dataset. If it still doesn’t find it, it will use the “prefix” where the library CMOR is to be installed (from configure time) followed by share (e.g /usr/local/cmor/share). If it stills fails an error will be raised.


---

### cmor_set_table

<span style="color:green">Fortran: cmor_set_table(table_id)</span>

<span style="color:blue">C: error_flag = cmor_set_table(int table_id)</span>

<span style="color:coral">Python: table_id = set_table(table_id)</span>

**Description:** Sets the table referred to by table_id as the table to obtain needed information when defining CMOR components (variables, axes, grids, etc…).

---

